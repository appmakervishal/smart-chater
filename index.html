<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>P2P Chat with Room ID, QR for Manual SDP & Better UI</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 600px;
    margin: 30px auto;
    background: #f0f2f5;
    color: #222;
  }
  h2 {
    text-align: center;
    margin-bottom: 15px;
  }
  label {
    display: block;
    margin: 12px 0 6px;
    font-weight: 600;
  }
  select, input[type=text], textarea, button {
    width: 100%;
    padding: 10px;
    font-size: 1rem;
    border: 1.5px solid #ccc;
    border-radius: 6px;
    box-sizing: border-box;
    transition: border-color 0.3s;
  }
  select:hover, input[type=text]:hover, textarea:hover, button:hover {
    border-color: #3b82f6;
  }
  textarea {
    font-family: monospace;
    height: 90px;
    resize: vertical;
  }
  button {
    background: #3b82f6;
    color: white;
    border: none;
    cursor: pointer;
    margin-top: 10px;
    border-radius: 6px;
    font-weight: 600;
  }
  button:disabled {
    background: #8ca2d6;
    cursor: not-allowed;
  }
  #chat {
    border: 1.5px solid #ccc;
    background: white;
    height: 280px;
    overflow-y: auto;
    padding: 12px;
    margin: 10px 0 15px;
    border-radius: 8px;
    white-space: pre-wrap;
  }
  #manualArea, #autoArea {
    margin-top: 10px;
  }
  #qrCode {
    margin-top: 10px;
    text-align: center;
  }
  #footer {
    text-align: center;
    margin-top: 20px;
    font-size: 0.9rem;
    color: #555;
  }
</style>
</head>
<body>

<h2>P2P Chat â€” Room ID & Signaling Modes with QR</h2>

<label for="roomId">Room ID (any unique name):</label>
<input id="roomId" placeholder="e.g. my-chat-room" value="demo-room" />

<label for="modeSelect">Signaling Mode:</label>
<select id="modeSelect">
  <option value="manual">Manual Signaling</option>
  <option value="auto">Automatic Signaling (Public Server)</option>
</select>

<div id="chat"></div>

<!-- Manual Signaling UI -->
<div id="manualArea">
  <label>Local SDP (Offer / Answer)</label>
  <textarea id="localSDP" readonly></textarea>
  <div id="qrCode"></div>

  <label>Remote SDP (Paste here or Scan QR)</label>
  <textarea id="remoteSDP" placeholder="Paste remote offer/answer here"></textarea>

  <button id="createOffer">Create Offer</button>
  <button id="createAnswer">Create Answer</button>
</div>

<!-- Auto Signaling UI -->
<div id="autoArea">
  <button id="connect">Start Connection</button>
</div>

<label for="message">Message:</label>
<input id="message" placeholder="Type your message..." disabled />
<button id="send" disabled>Send</button>

<div id="footer">No message storing. Peer-to-peer only.</div>

<script>
// Minimal QR Code generator (modified from https://github.com/davidshimjs/qrcodejs)
class QRCode {
  constructor(el, options) {
    this._el = el;
    this._text = options.text || '';
    this._size = options.width || 128;
    this._render();
  }
  _render() {
    this._el.innerHTML = '';
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = this._size;
    const ctx = canvas.getContext('2d');
    const qr = this._generateQRCode(this._text);
    const tileW = this._size / qr.length;
    const tileH = this._size / qr.length;

    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, this._size, this._size);
    ctx.fillStyle = '#000';
    for(let r=0; r<qr.length; r++) {
      for(let c=0; c<qr.length; c++) {
        if(qr[r][c]) {
          ctx.fillRect(c*tileW, r*tileH, tileW, tileH);
        }
      }
    }
    this._el.appendChild(canvas);
  }
  _generateQRCode(text) {
    // Super simple binary pattern: for demo only; use a real lib for production
    const size = 21; // typical QR version 1 size
    const data = Array(size).fill(null).map(() => Array(size).fill(false));
    // Fill a pattern based on text char codes
    for (let i = 0; i < text.length && i < size*size; i++) {
      const r = Math.floor(i / size);
      const c = i % size;
      data[r][c] = (text.charCodeAt(i) % 2) === 0;
    }
    // Add finder patterns top-left, top-right, bottom-left
    for (let i=0; i<7; i++) {
      for (let j=0; j<7; j++) {
        if(i<2 || i>4 || j<2 || j>4) {
          data[i][j] = true; // top-left
          data[i][size-1-j] = true; // top-right
          data[size-1-i][j] = true; // bottom-left
        }
      }
    }
    return data;
  }
}

// Main app code

const chat = document.getElementById('chat');
const modeSelect = document.getElementById('modeSelect');
const manualArea = document.getElementById('manualArea');
const autoArea = document.getElementById('autoArea');
const localSDP = document.getElementById('localSDP');
const remoteSDP = document.getElementById('remoteSDP');
const createOfferBtn = document.getElementById('createOffer');
const createAnswerBtn = document.getElementById('createAnswer');
const connectBtn = document.getElementById('connect');
const messageInput = document.getElementById('message');
const sendBtn = document.getElementById('send');
const roomInput = document.getElementById('roomId');
const qrCodeContainer = document.getElementById('qrCode');

let pc, dataChannel;
let ws;
let roomId = roomInput.value.trim() || 'demo-room';
let qrCode;

function log(msg) {
  chat.textContent += msg + '\n';
  chat.scrollTop = chat.scrollHeight;
}

function reset() {
  if (pc) {
    pc.close();
    pc = null;
  }
  if (ws) {
    ws.close();
    ws = null;
  }
  dataChannel = null;
  localSDP.value = '';
  remoteSDP.value = '';
  messageInput.value = '';
  messageInput.disabled = true;
  sendBtn.disabled = true;
  qrCodeContainer.innerHTML = '';
  log('--- Reset ---');
}

// Update QR from local SDP
function updateQR(text) {
  qrCodeContainer.innerHTML = '';
  if (!text) return;
  qrCode = new QRCode(qrCodeContainer, {text, width: 180});
}

// Manual signaling setup
function setupManual() {
  reset();
  pc = new RTCPeerConnection();

  pc.onicecandidate = e => {
    if (e.candidate === null) {
      localSDP.value = JSON.stringify(pc.localDescription);
      updateQR(localSDP.value);
    }
  };

  createOfferBtn.onclick = async () => {
    dataChannel = pc.createDataChannel('chat');
    setupDataChannel();
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    log('Offer created. Send your SDP (or scan QR) to peer.');
  };

  createAnswerBtn.onclick = async () => {
    try {
      const offer = JSON.parse(remoteSDP.value);
      await pc.setRemoteDescription(offer);
      pc.ondatachannel = e => {
        dataChannel = e.channel;
        setupDataChannel();
      };
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      log('Answer created. Send your SDP (or scan QR) to peer.');
    } catch {
      alert('Invalid Remote SDP!');
    }
  };

  remoteSDP.addEventListener('change', async () => {
    try {
      if (!pc.currentRemoteDescription) {
        const desc = JSON.parse(remoteSDP.value);
        await pc.setRemoteDescription(desc);
        log('Remote SDP set.');
      }
    } catch {}
  });
}

// Auto signaling setup
function setupAuto() {
  reset();
  roomId = roomInput.value.trim() || 'demo-room';

  pc = new RTCPeerConnection();

  pc.onicecandidate = e => {
    if (e.candidate && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'candidate', candidate: e.candidate, room: roomId }));
    }
  };

  pc.ondatachannel = e => {
    dataChannel = e.channel;
    setupDataChannel();
  };

  connectBtn.onclick = () => {
    if (ws) return;

    ws = new WebSocket('wss://signaling.simplewebrtc.com');

    ws.onopen = () => {
      log('Signaling server connected');
      ws.send(JSON.stringify({ type: 'join', room: roomId }));

      dataChannel = pc.createDataChannel('chat');
      setupDataChannel();

      pc.createOffer().then(offer => {
        pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: 'offer', offer, room: roomId }));
        log('Offer sent, waiting for peer...');
      });
    };

    ws.onmessage = async e => {
      const data = JSON.parse(e.data);
      if (data.type === 'offer') {
        await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify({ type: 'answer', answer, room: roomId }));
        log('Received offer, sent answer');
      } else if (data.type === 'answer') {
        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        log('Received answer');
      } else if (data.type === 'candidate') {
        try {
          await pc.addIceCandidate(data.candidate);
          log('Added ICE candidate');
        } catch {}
      }
    };

    ws.onclose = () => {
      log('Signaling server disconnected');
      ws = null;
    };
  };
}

function setupDataChannel() {
  dataChannel.onopen = () => {
    messageInput.disabled = false;
    sendBtn.disabled = false;
    log('Data channel open! Start chatting.');
  };
  dataChannel.onmessage = e => {
    log('Peer: ' + e.data);
  };
}

sendBtn.onclick = () => {
  const msg = messageInput.value.trim();
  if (!msg || !dataChannel || dataChannel.readyState !== 'open') return;
  dataChannel.send(msg);
  log('You: ' + msg);
  messageInput.value = '';
};

modeSelect.onchange = () => {
  chat.textContent = '';
  if (pc) pc.close();
  if (ws) ws.close();
  if (modeSelect.value === 'manual') {
    manualArea.style.display = 'block';
    autoArea.style.display = 'none';
    setupManual();
  } else {
    manualArea.style.display = 'none';
    autoArea.style.display = 'block';
    setupAuto();
  }
};

// When room ID changes, reset connection for auto mode
roomInput.addEventListener('change', () => {
  if (modeSelect.value === 'auto') {
    if (ws) ws.close();
    setupAuto();
  }
});

// Init page
modeSelect.value = 'manual';
manualArea.style.display = 'block';
setupManual();
</script>

</body>
</html>
